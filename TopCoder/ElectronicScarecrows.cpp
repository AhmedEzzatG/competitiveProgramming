#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;
#define endl "\n"
#define ll long long
#define sz(s) (int)(s.size())
#define INF 0x3f3f3f3f3f3f3f3fLL
#define all(v) v.begin(),v.end()
#define watch(x) cout<<(#x)<<" = "<<x<<endl
const int dr[] { -1, -1, 0, 1, 1, 1, 0, -1 };
const int dc[] { 0, 1, 1, 1, 0, -1, -1, -1 };

typedef complex<int> point;
#define PI acos(-1.0)
#define EPS 1e-8
#define X real()
#define Y imag()
#define angle(a)  (atan2((a).imag(), (a).real()))
#define dist(a)   (hypot((a).imag(), (a).real()))
#define length(a) dist(a)
#define vec(a,b)  ((b)-(a))
#define rotateO(p,ang)    ((p)*exp(point(0,ang)))
#define rotateA(p,ang,about)  (rotateO(vec(about,p),ang)+about)
#define same(p1,p2)             (dp(vec(p1,p2),vec(p1,p2)) < EPS)
#define dp(a,b)   ( (conj(a)*(b)).real() )
#define cp(a,b)   ( (conj(a)*(b)).imag() )
#define reflectO(v,m)  (conj((v)/(m))*(m))
#define normalize(a)            (a)/dist(a)
int dcmp(double x, double y) {
	if (fabs(x - y) <= EPS)
		return 0;
	return (x < y ? -1 : 1);
}

bool cmp(point a, point b) {
	return a.X < b.X || (a.X == b.X && a.Y < b.Y);
}

ll cross(point a, point b, point c) {
	return cp(vec(a,b), vec(b,c));
}

bool cw(point a, point b, point c) {
	return cross(a, b, c) < 0;
	//return a.X * (b.Y - c.Y) + b.X * (c.Y - a.Y) + c.X * (a.Y - b.Y) < 0;
}

bool ccw(point a, point b, point c) {
	return cross(a, b, c) > 0;
	//return a.X * (b.Y - c.Y) + b.X * (c.Y - a.Y) + c.X * (a.Y - b.Y) > 0;
}

vector<point> convex_hull(vector<point> &p) {
	if (p.size() == 1)
		return p;

	sort(p.begin(), p.end(), &cmp);
	point p1 = p[0], p2 = p.back();
	vector<point> up, down;
	up.push_back(p1);
	down.push_back(p1);
	for (int i = 1; i < (int) p.size(); i++) {
		if (i == p.size() - 1 || cw(p1, p[i], p2)) {
			while (up.size() >= 2
					&& !cw(up[up.size() - 2], up[up.size() - 1], p[i]))
				up.pop_back();
			up.push_back(p[i]);
		}
		if (i == p.size() - 1 || ccw(p1, p[i], p2)) {
			while (down.size() >= 2
					&& !ccw(down[down.size() - 2], down[down.size() - 1], p[i]))
				down.pop_back();
			down.push_back(p[i]);
		}
	}

	vector<point> convex;
	for (int i = 0; i < (int) down.size(); i++)
		convex.push_back(down[i]);
	for (int i = up.size() - 2; i > 0; i--)
		convex.push_back(up[i]);
	return convex;
}

class ElectronicScarecrows {
	static const int N = 41;
	int mem[N][N][N], n;
	vector<point> v;
	int solve(int last, int start, int cnt) {
		int &rt = mem[start][last][cnt];
		if (~rt)
			return rt;
		rt = cp(v[last], v[start]);
		if (cnt == n)
			return rt;
		for (int cur = last + 1; cur < v.size(); cur++)
			rt = max(rt, cp(v[last],v[cur]) + solve(cur, start, cnt + 1));
		return rt;
	}
public:
	double largestArea(vector<int> x, vector<int> y, int n) {
		this->n = n;
		memset(mem, -1, sizeof mem);
		v = vector<point>(x.size());
		for (int i = 0; i < x.size(); i++)
			v[i] = point(x[i], y[i]);
		v = convex_hull(v);
		int mx = 0;
		for (int i = 0; i < v.size(); i++)
			mx = max(mx, solve(i, i, 1));
		return mx * 0.5;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, double p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	ElectronicScarecrows *obj;
	double answer;
	obj = new ElectronicScarecrows();
	clock_t startTime = clock();
	answer = obj->largestArea(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	double p3;
	
	{
	// ----- test 0 -----
	int t0[] = {2,1,6,5,3,7,9};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,5,1,5,7,6,4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4;
	p3 = 24.0;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {183,229,723,510,395,936,447,328};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1000,823,0,412,786,446,312,286};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 15;
	p3 = 347200.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {33,36,26,8,12,8,28,19,8,37,9,22,31,30,25};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {12,8,6,16,27,7,31,33,35,22,22,36,29,22,32};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 8;
	p3 = 740.5;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {327,196,744,91,709,38,944,300,927,715,835,874,958,667,748,511,377,956,184,956,809,925,12,45,184,180,169,374,914,398,954,875,286,422,76,315,497,209,512,938};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {913,843,73,213,903,444,444,905,352,54,194,207,373,57,105,959,932,480,843,424,140,661,578,616,851,132,135,936,676,23,578,737,74,959,724,924,955,854,958,376};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 25;
	p3 = 685819.5;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING






//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
